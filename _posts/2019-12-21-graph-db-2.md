---
layout: post
title: Graph Database (2) - alternatives
description: "备选方案"
modified: 2019-12-22
tags: [graph database, tech]

---

## 如何存储属性

不同类型的边有不同的属性。当我们要在同一个表中存储不同种类的边的时候，我们可以对共有的属性创建对应的列，比如起始节点，目标节点，但是我们如何存储不同的属性呢？下面列举了几种方案。

1. 用不同的表来存储不同种类的边，这样我们实现了用户可定制化的属性和索引。
    1. 当我们在对表进行分片的时候，次级索引只能对当前分片的数据进行索引，因此，依赖于次级索引的查询需要被发送到所有的分片。这会导致查询效率低下，速度也慢。如果想要高效的按照属性的值来访问，就需要创建另一个表作为这个属性的次级索引。

    2. 这种方案不能解决表的总体数量的不断增加的问题，但是可以提供一个统一的接口来访问这些数据，同时对访问边的代码做一层抽象，把复杂的分片，分页，缓存，和计数实体化的逻辑隐藏起来。

    3. 这种方案可以在不迁移已经存在的大量数据的前提下，使用新的边存储模型，以及对应的代码和接口。

    4. 当需要改变表的结构/定义的时候，比如添加一种新的类型的边，我们仍然需要人工操作。当表变得越来越大的时候，改变表的结构会带来很多的运维负担，也导致数据库的高负载。

2. 类似 Facebook 的方式，但是一点改进是使用数据库原生支持的数据类型 JSON 来存储所有自由定义的属性：
    1. FB 也把属性序列化成 JSON 格式，但是由于旧版本的数据库，比如 MySql 5.1 并不原生支持 JSON 数据类型，所以列的数据类型被定义为 TEXT/BLOB。

    2. 在 FB，所有的边都有类型，但是所有的边都被存储在同一个逻辑表中。这个表被水平分片。

    3. 当我们考虑使用数据库原生支持的 JSON 数据类型时，需要考虑对 JSON 本身定义的分隔符进行转码。

    4. JSON 数据类型相对于其他，冗余的字符比较多，比如属性的名字。在这种情况，使用带压缩功能的存储引擎更为合适，比如使用MyRocks（Mysql 使用嵌入式引擎 RocksDB）。

3. 类似 Pinterest 的方式：在边的存储模型中，对于每种不同的边，用数字来命名属于这种边的属性。对应到数据库中的表，就是表的结构中会包含提前定义好的通用的列，比如 attr1， attr2，……，attrN，同时使用二进制的数据类型来存储所有的数据。只有在边的类型定义中，才能得到这些属性的真实名字和值。因为大多数数据库，比如 MySql 存储 null 是非常高效的，所以我们可以广泛的使用这种模式。每行，也就是每个边，最多允许有50个属性。
    1. 优点：这种结构对于大多数低版本数据库都适用。

    2. 缺点：数据库中没有值的数据类型

    3. 缺点：不是一种优雅的实现方式。同时，当我们想要调试数据的时候，会拿到一个通用的没有任何意义的列的名字。我们需要查询边的类型的定义才能知道这些数据的具体含义。

    4. 想要改变属性所对应的数字，或者说列的位置，是非常复杂的。我们需要重新创建这个表。一般来说，如果我们不再需要一个属性了，这个属性对应的列会被留空。

4. 把同一条边的不同属性存储为不同的行。简单来说，我们可以用一个通用的列，比如 “attr_name” 和 “attr_value” 作为表中的两列。存储名字的列的数据类型为字符型（varchar），而值的那一列，数据类型为二进制型（varbinary）。如果一个边有10个属性，那么我们就生成10行数据。每一行都有属性的名字和属性的值。这些所有的行都会被连续的储存在相邻的存储空间。
    1. 如果我们想要支持不同的数据类型，这种存储模式无疑增加了复杂性。因为值本身不带有数据类型，需要额外定义。

    2. 我们会对边进行比较复杂的操作，把一个逻辑行转换成几个行会增加额外的复杂性。

    3. 如果我们使用这种方案，那么存储引擎需要有比较好的压缩能力，比如使用 MyRocks。因为共有的属性会被重复存储 N 次，N是可定制的属性的个数。MyRocks 提供基于前缀的压缩可以避免磁盘空间的浪费。

    4. 这种把列转行成了行的方案，会使得导出数据的过程变得复杂。例如，如果想要保持与旧的数据兼容性，从 MySql 到 Hive 的导出操作就需要额外的步骤，就是把不同的行合并成同一个行的不同列。 一个例子[^1]。

## 最终方案

最合适的方案是使用（1）和 （2）的混合模型。

对于已经存在的存储关系的表，方案（1）可以让他们受益于新的边存储模型的代码或者接口，比如分页等，同时又不需要做复杂的数据迁移。默认情况下，他们被认为是一个分片，但是对于已经分片的表，也可以配置对应的分片模型，这些表继续使用已经存在的次级索引。数据仍然在原来的表中，只是在上面适配了新的接口。

对于新加入的存储关系的表，我们将使用方案（2），利用 JSON 数据类型来存储用户自定义的属性。

当一个旧的表越来越大，需要被分片的时候，我们就可以考虑把这个表迁移到新的边存储模型。在此之外，如果我们想要对已经存在的表的计数进行实体化，也可以在这个时候把这个表迁移到新的存储模型中。

### 节点需要被分成两类：被 ID 标识的节点，和被字符串标识的节点

对于已经存的表，他们继续使用现在的表结构。

对于新加入的表，这里有三种解决方案：

1. 创建两种不同的表，一个服务于被 ID 标识的节点对应的边，另一个服务于被字符串标识的节点对应的边。
    * 前一种表，出发节点是被 ID 标识的节点，分片也依赖于这些节点的 ID。后面的一种表，出发节点是被字符串标识的，同样，分片也依赖于字符串。这两种表同样定义有目标节点。根据不同目标节点的标识符类型，每种表都有两张表，所以总共有四张表，分别是 id_string, id_id, string_id, stirng_string。对于这四个表，主键类似，都是：边的类型 + 出发节点标识符 + 目标节点标识符。

    * 同理，我们也有四个表来记录反向的边。这四个表，主键也相互类似，都是：边的类型 + 目标节点标识符 + 出发节点标识符。

    * 合并这四个表成为一个表也是可能的，由于数据类型不同，我们需要更多的共有属性来记录不同的边。这时，共有的列包括：边的类型，被 ID 标识的出发节点，被字符串标识的出发节点，被 ID 标识的目标节点，被字符串标识的目标节点。对于一条边，如果它的节点是以 ID 标识，那么字符串标识的列就被设置为一个默认值。同理，如果节点是被字符串标识的，那么 ID 对应的边就是一个默认值。同时，主键也被设置为：边的类型 + 目标节点标识符 ID + 目标节点标识符字符串 + 出发节点标识符 ID + 出发节点标识符字符串。这个方案需要更复杂的分片功能，因为需要按照复合索引进行分片。

2. 合并被 ID 标识的节点和被字符串标识的节点到同一列
    将这两种类型的标识符存储到同一数据类型的列中，比如二进制类型（varbinary）的列。我们可以根据这个数据类型来分片，不会增加额外的逻辑来支持复杂的分片，但是从整型或者字符串到二进制类型的转化引入了其他的操作。当我们想要保持一个排好序的状态，那么对于整型到二进制类型的转换，高位优先和低位优先有着重要的影响。同理，转换字符串到整型的时候，字符集和排序规则同样有着关键的影响。把他们转换成二进制类型会导致排序的变化。

3. 通过另一个表来生成字符串的标识码
    我们可以使用另一个表的自增列来生成字符串的标识码。这样表中的节点就都有标识码。这种方案会使用更多的磁盘空间，同时增加访问时的资源消耗，因为有一步额外的查询操作。

[^1]: <https://stackoverflow.com/questions/1241178/mysql-rows-to-columns>
