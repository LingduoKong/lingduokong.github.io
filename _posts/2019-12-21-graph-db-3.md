---
layout: post
title: Graph Database (3) - system overview
description: "系统概述，表的定义和分片"
modified: 2019-12-23
tags: [graph database, tech]

---


## 定义边的类型

当定义一个边的时候，需要考虑以下这些内容：

1. 边的类型的名字
    1. 对于已经存在的表，使用和当前存在的表保持一致。

2. 这个类型在使用已经存在的表，还是一个新的表。

3. 出发节点的标识符是整型还是字符串。
    1. 同时，指明出发节点是由哪个表定义的。这样可以方便一致性检查和调试。一般不会在插入和更新的时候强制要求这一点，因为这会消耗太多资源。

    2. 对于已经存在的表，同时记录哪一列是出发节点标识符。

4. 目标节点的标识符是整型还是字符串。
    1. 与（3）类似，指明目标节点所对应的表，方便调试和一致性检测。在插入和更新的时候不作要求，因为消耗资源。
        * 理论上来讲，一个用户可以关注另一个用户，或者一个话题，或者一个问答等等。从这个角度来看，目标节点可以属于任何表。然而如果我们把这些关系根据关注目标的不同而分成不同的边的类型，目标节点的类型就会清楚了。自增 ID 在同一个表内是独一无二的，但是不能保证不同表之间的唯一性。使用不同的边的类型解决了唯一性的问题。

    2. 对于已经存在的表，同样的指明哪一行是目标节点标识符。

5. 对于每一个属性，定义书名的名字，数据类型，和默认值。
    1. 对于已经存在的表，使用与旧有的列同样的数据类型和名字。
        * 同时，指明哪一个属性是被用来排序的属性。如果有这个属性，那么在按顺序扫描的接口中，使用这个属性来排序。

    2. 对于在边存储模型中的新表，一个列“sortby”可以作为默认列永远存在，无需专门定义。
        1. 有应用来界定是否加入创建时间，更新时间，等等。将会创建一个次级索引来按照“sortby”的顺序读取边。

        2. 开放问题：是否支持“sortby_int”和“sortby_varchar”? 有三种可能的实现方式：
            1. 创建两个不同的次级索引来支持他们。

            2. 创建两种不同的表，一种表的排序列是整型，另一种的排序列是字符串。

            3. 大多数情况下，我们我们只有一种排好序的属性，属性的数据类型是整型。可以只创建一个次级索引，但它是符合索引，第一个列是“sortby_int”，第二个列是“sortby_varchar”。如果应用层使用整型作为排序列，我们将字符串列设为null，反之，我们将整型列设为0. 连个列不能同时使用。

        3. 开放问题：如果有第二个整型列或者第二个字符型列需要被排序，我们是否支持这种情况？两种可能的解决方案：
            1. 创建四个次级索引的来支持四种排序方式：如果当前这种边的类型不使用他们，那么会对这些边的类型带来太多的额外操作。

            2. 创建一个新表“EdgeOtherSortOrders”。这个表根据节点标识符来排序，这样从这个节点出发/终止的所有边都会被存储在一起。这样我们可以支持多个排序列，而不生成过多的次级索引。

6. 指定你想要的索引：同时指明是对正向边还是反向边做索引，或者两者都有。
    1. 这个索引可以被用于等式型的查询。例如：
        1. 某一个属性有指定的值：这些查询会去到同一个分片。

        2. （如果对正向边建索引）指定一个出发节点，和一个属性的值。

        3. （如果对反向边建索引）指定一个目标节点，和一个属性的值。

    2. 这个索引可以被用于等式行查询，例如：
        1. 属性的值在某一个范围内：这种查询会被发送到所有的分片，但是在同一个分片内，这个查询仍然是高效的。

        2. （如果对正向边建索引）指定出发节点，同时限制属性的值在某一个范围：因为索引的顺序是（属性的值，出发节点标识符），所以这种查询并不是很高效。同时，这个查询也需要被发到所有的分片上。

        3. （如果对反向边建索引）指定目标节点，同时限制属性的值在某一个范围：同上，索引的顺序是（属性的值，目标节点标识符），所以这种查询不高效，而且也需要被发送到所有的分片上。

    3. 如何处理遗留的表不能很好的适配上述模式，例如符合索引等等：
        1. 边查询模型并不会知道这些索引是否存在，所以需要重新检查这些索引，以确定他们是否是必须的。

        2. 在更新表的结构的时候，边的类型定义并不会修改遗留的表，它只是做完整性检查，确保边的类型定义与实际上的表的定义互相匹配。

    4. 是否能够支持这种情况：有时我们想要在边存储模型中创建一种符合索引，它包含两个及以上的属性：
        1. 我们需要定义一个特殊的属性，这个属性由几个不同的值构成。不同的值之间使用分隔符来分隔。用这个属性取代单独的几个属性。

        2. 几乎不可能按照范围来进行查询。

7. 是否存储反向边。
    * 对于遗留的表，这是不可能的。遗留的旧表大多数情况下都只有一个分片。对于这种表，使用次级索引可以高效的查询目标节点。但是对于有多个分片的情况，我们需要创建一个表来存储反向的边，因为正向的边对应的表是按照出发节点来分片，而反向边对应的表是按照目标节点来分片。

8. 是否对于正向的边进行计数。
    1. 对于遗留的表，指明存储计数的表的名字。

9. 是否对于反向的边进行计数。

## 不同的表的定义

如上文所说，对于遗留的表，边存储模型将不会创建的新的表。对于使用边存储模型的新表，我们创建以下的几个表：

1. EdgesByNodeID
    1. edge_type, source_node_ID, dest_node_ID, dest_node_key, sortby, create_time, update_time, other_attrs

    2. 这个表按照出发节点标识符来分片。

    3. 主键：edge_type, source_node_ID, dest_node_ID, dest_node_key

    4. 创建时间和更新时间应该由数据库自己生成，主要用来调试。

    5. 次级索引：edge_type, source_node_ID, sortby, dest_node_ID, dest_node_key

    6. 其他的属性是一个 JSON 类型的列。

2. EdgesByNodeKey
    1. 这个表并不是必须的，取决于时候有节点会使用字符串作为标识符。如果有的话，结构和（1）类似，只是把 source_node_ID 替换为 source_node_key。

3. BackEdgesByNodeID
    1. 结构和（1）非常类似，主要区别有两点，首先目标节点和出发节点调换位置，其次没有 JSON 列来存储其他属性。

    2. 使用 dest_node_ID 来分片。

    3. 不在重复的存储其他属性列，因为已经在正向边的表中。

4. BackEdgesByNodeKey
    1. 结构和（2）非常类似，主要区别有两点，首先目标节点和出发节点调换位置，其次没有 JSON 列来存储其他属性。

    2. 使用 dest_node_key 来分片。

    3. 不在重复的存储其他属性列，因为已经在正向边的表中。

5. EdgeCountsByNodeID
    1. edge_type, direction, node_ID, count

    2. 方向列指明边的方向，例如是正向边还是反向边。

    3. 按照节点标识符来分片：这样对于同一个节点，对于以他为顶点的边的计数，不论是正向边还是反向边，不论是作为出发节点还是目标节点，都是在同一个分片上。

6. EdgeCountsByNodeKey
    1. 和（5）的结构非常相似，唯一的区别是使用 node_key 来取代 node_ID。

7. EdgeIndex：它有两种可能的表的定义。主要取决于我们如何处理不同数据类型的属性。
    1. EdgeIndex(edge_type, edge_direction, attr_value_hash, attr_value_bigint, attr_value_varchar, first_node_ID, first_node_key, second_node_ID, second_node_key)
        * attr_value_bigint, attr_value_varchar 这两列中，只有一个有合法的值，另一个为默认值。合法值的哈希被存储在对应的哈希列中。

        * 这个表按照哈希列来分片。

        * 主键包含了所有的列。

        * 如果方向存储为正向，那么第一个节点存储出发节点，第二个节点存储目标节点。如果为反向，那么第一个节点为目标节点，第二个节点为出发节点。

        * 这种方案不能支持按照范围来查询。如果需要按照范围查询，还要在建另外的次级索引。即使这样，查询仍然会被发到所有的分片，因为没有使用原始的值来分片。

        * 期望按照哈希分片能够得到均匀的分片，但是不能保证。

    2. 和上面的方案（1）类似，区别是我们将创建两个不同的表，EdgeIndexBigint, EdgeIndexVarchar。以后如果需要支持其他数据类型，就创建其他的表。EdgeIndexBigint 只有 attr_value_bigint 列，而 EdgeIndexVarchar 只有 attr_value_varchar 列。
        * 优点：按照范围进行的查询不需要额外的次级索引。查询请求只会被发到某一个分片，除非这个范围横跨多个分片。

        * 缺点：分片可能不是很均衡。

8. EdgeOtherSortOrders：当我们需要支持多个排序属性的时候，使用这个表来作为索引，而不是在边对应的表上创建多个次级索引。表的结构类似于（7），但是有如下的不同点：
    1. 按照 first_node_ID 分片

    2. 主键会有一个额外的列 first_node_ID，位置在 attrValue 前面。
