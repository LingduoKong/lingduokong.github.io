---
layout: post
title: Graph Database (1) - background
description: "背景"
modified: 2019-12-21
tags: [graph database, tech]

---

实体与关系模型是关系型数据库的基础。在社交网络中，有很多实体。以推特为例，它的数据中有用户，推特，评论，等等。这些实体之间，存在着一些联系，我们称之为关系。

在最近的这十年内，社交网络型应用崛起。这些公司内部，通常使用图形化的语言来描述实体以及实体之间的关系。实体通常被称为“节点”，而关系被称为“边”。

当下大多数公司中，使用关系型数据库中的一个表来存储关系。例如我们可以使用一个表来存储“点赞”这个用户和评论之间的关系。随着时间的推移，业务的规模不断壮大，我们需要存储更多的不同的关系，所以创建了很多不同的表。针对不同的表，又有不同的代码来读写这些关系。

然而，不同类型的边在存储和读写模型上有很多共通之处。这里问题出现了：没有一个共用的/可以重用的抽象存储结构来存储和访问这些边。

## 存储和读写不同类型边的共通之处

* 表的结构是类似的。他们都有起始节点，目标节点，和一些属性，比如创建时间等等。

* 这些表通常使用复合索引作为他们的主键。复合索引由起始节点和目标节点的组成。

* 读写模型非常类似。例如：
  * 读取从起始节点出发的正向边，大多数带有分页的模式。

  * 读取从目标节点出发的反向边，大多数带有分页模式。

  * 对正向或反向的边进行计数。

## 设计中共有的问题与挑战

1. 分页：有些查询连续读取很多边，但是不使用分页。这样的查询会使得数据库资源利用产生很大的波动，同时也会和其他相对轻量级的请求竞争资源。同时，这样的查询容易导致请求超时。

2. 计数：随着存储的边越来越多，计数请求需要消耗大量的资源。
    1. 即使使用缓存，在足够长的时间内，缓存不能命中的事情都会发生。一个非常热门的数据集合或者计数结果，如果不能命中缓存，那么数据库过载的情况就极易发生。

    2. 因此，我们希望可以把计数实体化。比如把计数存在数据库里，然后实时更新这些计数。存储计数结果会给整个系统带来一些额外的负担，因为在添加或者删除边的时候，我们需要增加或者减少对应的数值。但是这使读取计数变得非常高效和便捷。通常社交网路型应用有更多的读取操作，而有相对较少的写操作，这种额外的负担是可以接受的。

    3. 原来读写边对应的数据的代码，现在也需要读写与这些边对应的计数表。

3. 当新的属性被添加到表的结构中时，我们需要修改已经存在的表的结构。
    1. 当表变得越来越大，这些修改表的结构的操作会给数据库带来很大的负载，同时额外增加了很多运维的工作。

4. 处理数据库分片和分表：当表变大，我们需要对他们进行分片。否则维护这些大的表是非常困难的。
    1. 如果我们通过正向边来分片，那些带有出发节点的操作会非常高效，因为这个操作只需要访问一个分片。然而使用目标节点的操作却是非常低效的，因为这些操作需要访问所有的分片。所以，如果我们把正向的边（从出发节点到目标节点）和反向的边（从目标节点到出发节点）分成两个表来存储，就可以保证两种操作都非常的高效。对于正向的边，我们通过出发节点来分片，对于反向的边，则通过目标节点来分片。

    2. 在分片的过程中，可以同时把已经存在的次级索引迁移到一个单独的表中。这个表通过属性的值来分片。

    3. 在代码中，原来读写边的操作，现在需要读写正向边，反向边，和索引对应的单独的表。

5. 检查并修复不一致的数据：按照这样的设计模式，我们将会有很多不同的表，比如“edge”表来存储正向边，“back edge”表来存储反向边，“index table”来存储索引表，“edge count”来存储边的计数。我们需要保证这些数据之间的一致性。
    1. 当数据分散在不同的 MySql 数据库中，而且可能有中间的数据访问层，我们几乎不可能支持事务。即使通过复杂的算法支持事务，访问数据的效率会因为锁或者死锁的缘故而大大降低。

    2. 目前一个较为通用的解决方案是容忍可控范围内的不一致数据。不停的检查并修复不一致数据。

6. 缓存：Redis 和 Memcached 都不是很适合用来缓存比较长的链表型数据结构。但是这又是一个大的话题，放在其他主题专门讲。
    1. Memcached 存储链表的方式是把它转换成一个二进制的对象，所以我们需要读取或者写入整个链表。这是非常低效率的操作。

    2. Redis 是一个单线程的模型。

与关系（边）的存储类似的是，我们会创建很多单独的表来存储不同的实体。同时也有很多针对特定业务的代码来读写这些实体。同样的问题：没有可共享的，可重用的架构来存储和访问节点（实体）。

## 抽象的意义

为每个种类的实体和关系创建单独的表，类似于我们在代码中创建了很多功能重复的函数。这显然有悖于软件工程的最佳实践。理想的情况是，我们应该从一开始就提供可重用的抽象，和实现这些抽象的通用的函数。通过这个方式，代码极大程度上得到了重用。这也是为什么 Facebook，Pinterest，Dropbox 等公司使用“边”和“节点”作为抽象，然后在这个抽象上搭建业务逻辑。

可能仍然有些表不能很好的被这些抽象的边和节点模型所取代。这种情况下，使用定制的表和代码仍然是可以接受的。但是尤其在社交网络类似的应用和公司中，大多数的表都适用这种模型。对于这类型的公司，非常值得构建这样一套可重用的抽象层来存储节点和边。

”边存储模型“，一种抽象模型来提供统一的接口存储和访问边，可以避免表的数量的无限制增长，同时把复杂的实现逻辑隐藏起来，比如分片，表内数据模型的更改，通过分页的方式扫描大量的数据，实体化计数，链表型数据结构的缓存，和发现并修正不一致的数据。

之后的文章中，我们会引入“节点存储模型”，来优化对节点的存储和访问。

“边存储模型”和“节点存储模型”，二者一起构成了“图数据库”。

## 从“边存储模型”开始

首先，相对于节点来说，不同种类的边有更多的相似之处。其次，对于 N 种不同的节点，那么就有 N^2 种不同的边来连接他们。因此，边比节点在以下方面有更多的技术挑战：顺序读取大量的数据，计数，从正向和反向来遍历，分片，缓存等等。这个抽象层对于边有着更为重要的意义。所以通常来说，优先构建“边存储模型”，然后再考虑“节点存储模型”。
